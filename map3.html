<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khwai Private Reserve Monitoring Dashboard</title>

    <!-- External CSS -->
    <link rel="stylesheet" href="styles.css" />

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Leaflet TextPath Plugin CSS -->
    <style>
        .leaflet-text-path {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Top Ribbon -->
    <div class="top-ribbon">
        <h1>Khwai Private Reserve Monitoring Dashboard</h1>
        <a href="https://jonobenjamin.github.io/WildlifeTracker-Front_End/" target="_blank" class="submit-data-btn">
            Submit Data
        </a>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Map Section (75% width) -->
        <div class="map-section">
            <div id="loading" class="loading">
                <div>Loading map data...</div>
            </div>
            <div id="map"></div>
        </div>

        <!-- Sidebar (40% width) -->
        <div class="sidebar">
            <h3>Filters & Controls</h3>

            <!-- View Mode Dropdown - MOVED TO TOP -->
            <div class="control-group">
                <h4>View Mode</h4>
                <select id="view-mode-select" class="view-select">
                    <option value="sightings" selected>Sightings</option>
                    <option value="maintenance">Maintenance</option>
                    <option value="incidents">Incidents</option>
                    <option value="water-monitoring">Water Monitoring</option>
                </select>
            </div>

            <!-- Date Range Controls -->
            <div class="control-group">
                <h4>Date Range</h4>
                <div class="date-controls">
                    <div class="date-control">
                        <label for="start-date">Start Date</label>
                        <input type="date" id="start-date">
                    </div>
                    <div class="date-control">
                        <label for="end-date">End Date</label>
                        <input type="date" id="end-date">
                    </div>
                </div>
            </div>

            <!-- Month/Year Selector -->
            <div class="control-group">
                <h4>Month & Year</h4>
                <div class="date-controls">
                    <div class="date-control">
                        <label for="month-select">Month</label>
                        <select id="month-select">
                            <option value="">All Months</option>
                            <option value="01">January</option>
                            <option value="02">February</option>
                            <option value="03">March</option>
                            <option value="04">April</option>
                            <option value="05">May</option>
                            <option value="06">June</option>
                            <option value="07">July</option>
                            <option value="08">August</option>
                            <option value="09">September</option>
                            <option value="10">October</option>
                            <option value="11">November</option>
                            <option value="12">December</option>
                        </select>
                    </div>
                    <div class="date-control">
                        <label for="year-select">Year</label>
                        <select id="year-select">
                            <option value="" selected>All Years</option>
                            <option value="2020">2020</option>
                            <option value="2021">2021</option>
                            <option value="2022">2022</option>
                            <option value="2023">2023</option>
                            <option value="2024">2024</option>
                            <option value="2025">2025</option>
                            <option value="2026">2026</option>
                            <option value="2027">2027</option>
                            <option value="2028">2028</option>
                            <option value="2029">2029</option>
                            <option value="2030">2030</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Species Filter (Sightings only) -->
            <div class="control-group" id="species-group" style="display: block;">
                <h4>Species Filter</h4>
                <div class="species-filter">
                    <select id="species-select">
                        <option value="">All Species</option>
                        <option value="elephant">Elephant</option>
                        <option value="lion">Lion</option>
                        <option value="leopard">Leopard</option>
                        <option value="buffalo">Buffalo</option>
                        <option value="giraffe">Giraffe</option>
                        <option value="zebra">Zebra</option>
                        <option value="wild-dog">Wild Dog</option>
                        <option value="hyena">Hyena</option>
                        <option value="cheetah">Cheetah</option>
                        <option value="hippo">Hippo</option>
                    </select>
                </div>

                <!-- Stats Display -->
                <div class="stats-display">
                    <span class="stat-number" id="total-records">0</span>
                    <span class="stat-label">Total Sightings</span>
                </div>

                <!-- Display Mode Switch -->
                <div class="control-group">
                    <h4>Display Mode</h4>
                    <div class="switch-container">
                        <label class="switch">
                            <input type="checkbox" id="display-mode-toggle">
                            <span class="slider round">
                                <span class="switch-text" data-on="Hotspots" data-off="Actual">Actual</span>
                            </span>
                        </label>
                    </div>
                </div>

                <!-- Latest Sightings Toggle -->
                <div class="latest-toggle">
                    <input type="checkbox" id="latest-sightings-toggle">
                    <label for="latest-sightings-toggle">Show Recent Sightings (This Week)</label>
                </div>

            </div>

            <!-- Maintenance Stats -->
            <div class="control-group" id="maintenance-group" style="display: none;">
                <h4>Maintenance Stats</h4>
                <div class="stats-display">
                    <span class="stat-number" id="maintenance-records">0</span>
                    <span class="stat-label">Total Maintenance</span>
                </div>

                <!-- Latest Maintenance Toggle -->
                <div class="latest-toggle">
                    <input type="checkbox" id="latest-maintenance-toggle">
                    <label for="latest-maintenance-toggle">Show Recent Maintenance (This Week)</label>
                </div>
            </div>

            <!-- Incidents Stats -->
            <div class="control-group" id="incidents-group" style="display: none;">
                <h4>Incidents Stats</h4>
                <div class="stats-display">
                    <span class="stat-number" id="incident-records">0</span>
                    <span class="stat-label">Total Incidents</span>
                </div>

                <!-- Latest Incidents Toggle -->
                <div class="latest-toggle">
                    <input type="checkbox" id="latest-incidents-toggle">
                    <label for="latest-incidents-toggle">Show Recent Incidents (This Week)</label>
                </div>
            </div>

            <!-- Water Monitoring Data Entry -->
            <div class="control-group" id="water-monitoring-group" style="display: none;">
                <h4>Water Monitoring</h4>

                <!-- Location Selection -->
                <div class="form-group">
                    <label for="water-location-select">Location</label>
                    <select id="water-location-select" class="view-select">
                        <option value="">Select Location</option>
                        <option value="tuludi">Tuludi</option>
                        <option value="sable-alley">Sable Alley</option>
                        <option value="little-sable">Little Sable</option>
                    </select>
                </div>

                <!-- Water Quality Parameters -->
                <div id="water-params" style="display: none;">
                    <div class="form-group">
                        <label for="cond-input">Cond (micro/cm)</label>
                        <input type="number" id="cond-input" step="0.01" placeholder="0.00">
                    </div>

                    <div class="form-group">
                        <label for="tds-input">TDS (ppm)</label>
                        <input type="number" id="tds-input" step="0.01" placeholder="0.00">
                    </div>

                    <div class="form-group">
                        <label for="as-input">As (ppm)</label>
                        <input type="number" id="as-input" step="0.01" placeholder="0.000">
                    </div>

                    <div class="form-group">
                        <label for="cr-input">Cr (ppm)</label>
                        <input type="number" id="cr-input" step="0.01" placeholder="0.000">
                    </div>

                    <div class="form-group">
                        <label for="cu-input">Cu (ppm)</label>
                        <input type="number" id="cu-input" step="0.01" placeholder="0.000">
                    </div>

                    <div class="form-group">
                        <label for="mn-input">Mn (ppm)</label>
                        <input type="number" id="mn-input" step="0.01" placeholder="0.000">
                    </div>

                    <div class="form-group">
                        <label for="na-input">Na (ppm)</label>
                        <input type="number" id="na-input" step="0.01" placeholder="0.000">
                    </div>

                    <div class="form-group">
                        <label for="pb-input">Pb (ppm)</label>
                        <input type="number" id="pb-input" step="0.01" placeholder="0.000">
                    </div>

                    <!-- Date Input -->
                    <div class="form-group">
                        <label for="water-date-input">Date</label>
                        <input type="date" id="water-date-input">
                    </div>

                    <!-- Submit Button -->
                    <button id="submit-water-data" class="btn-submit">Submit Water Data</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Ribbon -->
    <div class="bottom-ribbon">
        <p>© 2025 Khwai Private Reserve Monitoring System | Developed by <a href="mailto:jonobenjamingis@gmail.com">@jonathan Benjamin</a></p>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet Heat Plugin -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <!-- Leaflet TextPath Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-textpath@1.2.3/leaflet.textpath.min.js"></script>

    <!-- Chart.js for water monitoring graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>



    <script>
        // Simple Wildlife Tracker Map
        // Loads local GeoJSON for boundaries/roads, fetches Firebase observations

        // Configuration
        const API_BASE_URL = 'https://wildlife-tracker-gxz5.vercel.app';
        const API_KEY = '98394a83034f3db48e5acd3ef54bd622c5748ca5bb4fb3ff39c052319711c9a9';

        // Simple authentication function
        function getAuthHeaders() {
            return {
                'x-api-key': API_KEY,
                'Content-Type': 'application/json'
            };
        }

        // Initialize map
        const map = L.map('map').setView([-18.8, 23.8], 10); // Center on concession area

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 18,
        }).addTo(map);

        // Layer groups for different data types
        const boundaryLayer = L.layerGroup().addTo(map);
        const roadsLayer = L.layerGroup().addTo(map);
        const campsLayer = L.layerGroup().addTo(map);
        const observationsLayer = L.layerGroup().addTo(map);

        // Store markers by type for filtering
        const markersByType = {
            Sighting: [],
            Incident: [],
            Maintenance: []
        };

        // Species color mapping for legend
        const speciesColors = {
            'elephant': '#8B4513',    // Saddle brown
            'lion': '#DC143C',        // Crimson
            'leopard': '#DAA520',     // Goldenrod
            'buffalo': '#228B22',     // Forest green
            'giraffe': '#FF6347',     // Tomato
            'zebra': '#000000',       // Black
            'wild-dog': '#8A2BE2',    // Blue violet
            'hyena': '#696969',       // Dim gray
            'cheetah': '#FFD700',     // Gold
            'hippo': '#4682B4'        // Steel blue
        };

        // Current view state
        let currentView = 'sightings';
        let displayMode = 'actual'; // 'actual' or 'hotspot'
        let allObservations = [];
        let latestMarkers = [];
        let speciesLegend = null;

        // Water monitoring locations
        const waterMonitoringLocations = {
            'tuludi': {
                name: 'Tuludi',
                coords: [-19.138159, 23.564946],
                data: []
            },
            'sable-alley': {
                name: 'Sable Alley',
                coords: [-19.128241, 23.661295],
                data: []
            },
            'little-sable': {
                name: 'Little Sable',
                coords: [-19.151743, 23.695365],
                data: []
            }
        };

        // Water monitoring markers
        let waterMonitoringMarkers = [];

        // Simple marker icons - just colored points
        const createCustomIcon = (color) => {
            return L.divIcon({
                className: 'simple-marker',
                html: `<div style="
                    background-color: ${color};
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    border: 1px solid #000;
                "></div>`,
                iconSize: [8, 8],
                iconAnchor: [4, 4]
            });
        };


        const sightingIcon = createCustomIcon('#8B4513');  // Saddle brown for sightings
        const incidentIcon = createCustomIcon('#DC143C');   // Crimson for incidents
        const maintenanceIcon = createCustomIcon('#DAA520'); // Goldenrod for maintenance

        // Hide loading message
        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.style.display = 'none';
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = `<strong>Error:</strong> ${message}`;
            document.body.appendChild(errorDiv);

            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }

        // Load concession boundary from local file
        async function loadBoundary() {
            try {
                console.log('Loading concession boundary...');
                const response = await fetch('data/geojson/boundary.geojson');
                if (!response.ok) throw new Error(`Boundary file not found: ${response.status}`);

                const geoJson = await response.json();
                console.log('Boundary data loaded:', geoJson);

                L.geoJSON(geoJson, {
                    style: {
                        color: '#2D1810',     // Dark brown border
                        weight: 4,
                        opacity: 0.9,
                        fillColor: '#DEB887',  // Tan fill
                        fillOpacity: 0.3
                    }
                }).addTo(boundaryLayer);

                // Fit map to boundary bounds
                if (geoJson.features && geoJson.features.length > 0) {
                    const bounds = L.geoJSON(geoJson).getBounds();
                    map.fitBounds(bounds, { padding: [20, 20] });
                }

            } catch (error) {
                console.error('Error loading boundary:', error);
                showError('Failed to load concession boundary data');
            }
        }

        // Store road layers for zoom-based label management
        let roadLayers = [];

        // Function to update road labels based on zoom level
        function updateRoadLabels() {
            const zoom = map.getZoom();
            const minZoom = 14; // Only show labels at zoom 14 or higher (reduced overlap)

            roadLayers.forEach(({ layer, roadName }) => {
                // Clear existing text
                layer.setText(null);

                if (zoom >= minZoom) {
                    // Simply apply text - let it follow the natural path direction
                    layer.setText('  ' + roadName + '  ', {
                        repeat: false,
                        center: true,
                        offset: 8,
                        below: false,
                        attributes: {
                            'font-size': '13px',
                            'font-weight': 'bold',
                            'font-family': 'Arial, sans-serif',
                            'fill': '#000',
                            'stroke': '#fff',
                            'stroke-width': '3.5',
                            'paint-order': 'stroke',
                            'stroke-opacity': '0.9',
                            'letter-spacing': '1.5'
                        }
                    });
                }
            });
        }

        // Check if a coordinate array would create upside-down text
        function shouldReverseCoords(coords) {
            if (!coords || coords.length < 2) return false;

            // Get start and end points
            const start = coords[0];
            const end = coords[coords.length - 1];

            // Calculate the overall direction
            const dx = end[0] - start[0]; // longitude difference
            const dy = end[1] - start[1]; // latitude difference

            // Calculate angle in degrees
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);

            // Reverse if angle would make text upside-down
            // (pointing generally westward or southward: angle > 90 or < -90)
            return (angle > 90 || angle < -90);
        }

        // Load roads from local file
        async function loadRoads() {
            try {
                console.log('Loading roads...');
                const response = await fetch('data/geojson/KPR_roads.geojson');
                if (!response.ok) throw new Error(`Roads file not found: ${response.status}`);

                const geoJson = await response.json();
                console.log('Roads data loaded, features:', geoJson.features ? geoJson.features.length : 'none');

                // Pre-process features to reverse upside-down segments
                geoJson.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.type === 'MultiLineString') {
                        feature.geometry.coordinates = feature.geometry.coordinates.map(lineString => {
                            // Check if this linestring would create upside-down text
                            if (shouldReverseCoords(lineString)) {
                                return [...lineString].reverse();
                            }
                            return lineString;
                        });
                    } else if (feature.geometry && feature.geometry.type === 'LineString') {
                        if (shouldReverseCoords(feature.geometry.coordinates)) {
                            feature.geometry.coordinates = [...feature.geometry.coordinates].reverse();
                        }
                    }
                });

                const roadsGeoJson = L.geoJSON(geoJson, {
                    style: {
                        color: '#000',
                        weight: 2,
                        opacity: 0.9
                    },
                    onEachFeature: function (feature, layer) {
                        const roadName = feature.properties?.Roads || feature.properties?.name;

                        if (roadName) {
                            // Add popup
                            layer.bindPopup(`<strong>${roadName}</strong>`);

                            // Store layer for zoom-based label management
                            roadLayers.push({ layer, roadName });

                            console.log('Added road:', roadName);
                        }
                    }
                });

                roadsGeoJson.addTo(roadsLayer);
                console.log('Roads GeoJSON added to roadsLayer, features:', geoJson.features.length);

                // Set up zoom event listener for labels
                map.on('zoomend', updateRoadLabels);

                // Initial label update
                updateRoadLabels();

            } catch (error) {
                console.error('Error loading roads:', error);
                showError('Failed to load roads data');
            }
        }

        // Load camps from local file
        async function loadCamps() {
            try {
                console.log('Loading camps...');
                const response = await fetch('data/geojson/Camps.geojson');
                if (!response.ok) throw new Error(`Camps file not found: ${response.status}`);

                const geoJson = await response.json();
                console.log('Camps data loaded:', geoJson);

                // Create a custom icon for camps
                const campIcon = L.icon({
                    iconUrl: 'data/icons/KPR.svg',
                    iconSize: [24, 24], // Smaller than water monitoring markers
                    iconAnchor: [12, 24],
                    popupAnchor: [0, -24]
                });

                L.geoJSON(geoJson, {
                    pointToLayer: function(feature, latlng) {
                        return L.marker(latlng, { icon: campIcon });
                    },
                    onEachFeature: function(feature, layer) {
                        const campName = feature.properties?.Camps || 'Camp';
                        layer.bindPopup(`<strong>${campName}</strong><br><em>Camp Location</em>`);
                    }
                }).addTo(campsLayer);

                console.log('Camps loaded successfully');

            } catch (error) {
                console.error('Error loading camps:', error);
                showError('Failed to load camps data');
            }
        }

        // Load observations
        async function loadObservations() {
            try {
                console.log('Loading observations...');
                const response = await fetch(`${API_BASE_URL}/api/observations`, {
                    headers: getAuthHeaders()
                });
                if (!response.ok) throw new Error(`Observations API returned ${response.status}`);

                const data = await response.json();
                console.log('Observations data loaded:', data);
                console.log('Number of observations received:', data.data ? data.data.length : 0);

                if (data.success && data.data) {
                    allObservations = data.data; // Store all observations
                    console.log('Sample observations:', data.data.slice(0, 3).map(obs => ({
                        category: obs.category,
                        timestamp: obs.timestamp,
                        animal: obs.animal,
                        lat: obs.latitude,
                        lng: obs.longitude
                    })));


                    data.data.forEach(observation => {
                        if (observation.latitude && observation.longitude) {
                            let icon, popupContent;

                            switch (observation.category) {
                                case 'Sighting':
                                    // Use species-specific color for sightings
                                    const animalName = (observation.animal || '').toLowerCase().replace(/\s+/g, '-');
                                    const speciesColor = speciesColors[animalName] || '#8B4513';
                                    icon = createCustomIcon(speciesColor);
                                    popupContent = `
                                        <strong>Animal Sighting</strong><br>
                                        <strong>Species:</strong> ${observation.animal || 'Unknown'}<br>
                                        <strong>Time:</strong> ${new Date(observation.timestamp).toLocaleString()}<br>
                                        <strong>Location:</strong> ${observation.latitude.toFixed(4)}, ${observation.longitude.toFixed(4)}
                                    `;
                                    break;
                                case 'Incident':
                                    icon = incidentIcon;
                                    popupContent = `
                                        <strong>Incident Report</strong><br>
                                        <strong>Type:</strong> ${observation.incident_type || 'Unknown'}<br>
                                        <strong>Time:</strong> ${new Date(observation.timestamp).toLocaleString()}<br>
                                        <strong>Location:</strong> ${observation.latitude.toFixed(4)}, ${observation.longitude.toFixed(4)}
                                    `;
                                    break;
                                case 'Maintenance':
                                    icon = maintenanceIcon;
                                    popupContent = `
                                        <strong>Maintenance Activity</strong><br>
                                        <strong>Type:</strong> ${observation.maintenance_type || 'Unknown'}<br>
                                        <strong>Time:</strong> ${new Date(observation.timestamp).toLocaleString()}<br>
                                        <strong>Location:</strong> ${observation.latitude.toFixed(4)}, ${observation.longitude.toFixed(4)}
                                    `;
                                    break;
                                default:
                                    icon = sightingIcon;
                                    popupContent = `
                                        <strong>Observation</strong><br>
                                        <strong>Category:</strong> ${observation.category}<br>
                                        <strong>Time:</strong> ${new Date(observation.timestamp).toLocaleString()}<br>
                                        <strong>Location:</strong> ${observation.latitude.toFixed(4)}, ${observation.longitude.toFixed(4)}
                                    `;
                            }

                            const marker = L.marker([observation.latitude, observation.longitude], { icon })
                                .bindPopup(popupContent);

                            // Add marker to map layer
                            marker.addTo(observationsLayer);

                            // Store marker by type for filtering
                            if (markersByType[observation.category]) {
                                markersByType[observation.category].push(marker);
                            }
                        }
                    });

                    // Apply current filters and view
                    applyFilters();
                    updateStats();

                    // Show species legend at startup if in sightings mode
                    if (currentView === 'sightings' && displayMode === 'actual') {
                        showSpeciesLegend();
                    }
                }

            } catch (error) {
                console.error('Error loading observations:', error);
                showError('Failed to load observation data. Check your connection and try again.');
            }
        }

        // Initialize map data loading
        async function initMap() {
            try {
                await Promise.all([
                    loadBoundary(),
                    loadRoads(),
                    loadCamps(),
                    loadObservations()
                ]);

                // Always show water monitoring markers
                showWaterMonitoringMarkers();

                hideLoading();
                console.log('Map initialization complete');
            } catch (error) {
                console.error('Error initializing map:', error);
                hideLoading();
                showError('Failed to initialize map data. Check your connection and try again.');
            }
        }

        // Filter and control functions
        function toggleMarkers(type, show) {
            markersByType[type].forEach(marker => {
                if (show) {
                    if (!observationsLayer.hasLayer(marker)) {
                        marker.addTo(observationsLayer);
                    }
                } else {
                    if (observationsLayer.hasLayer(marker)) {
                        observationsLayer.removeLayer(marker);
                    }
                }
            });
        }

        function clearLatestMarkers() {
            latestMarkers.forEach(marker => {
                if (observationsLayer.hasLayer(marker)) {
                    observationsLayer.removeLayer(marker);
                }
            });
            latestMarkers = [];
        }

        function showSpeciesLegend() {
            // Remove existing legend
            if (speciesLegend) {
                map.removeControl(speciesLegend);
            }

            // Create new legend
            speciesLegend = L.control({ position: 'topright' });

            speciesLegend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'species-legend');
                div.innerHTML = `
                    <h4>Species Legend</h4>
                    ${Object.entries(speciesColors).map(([species, color]) => `
                        <div class="species-item">
                            <div class="species-dot" style="background-color: ${color}"></div>
                            <span class="species-name">${species.replace('-', ' ')}</span>
                        </div>
                    `).join('')}
                `;
                return div;
            };

            speciesLegend.addTo(map);
        }

        function hideSpeciesLegend() {
            if (speciesLegend) {
                map.removeControl(speciesLegend);
                speciesLegend = null;
            }
        }

        // Show water monitoring markers
        function showWaterMonitoringMarkers() {
            // Clear existing water monitoring markers
            hideWaterMonitoringMarkers();

            // Create custom icon using KPR.svg
            const waterMonitoringIcon = L.icon({
                iconUrl: 'data/icons/KPR.svg',
                iconSize: [32, 32], // Size of the icon
                iconAnchor: [16, 32], // Point of the icon which corresponds to marker's location
                popupAnchor: [0, -32] // Point from which the popup should open relative to the iconAnchor
            });

            Object.values(waterMonitoringLocations).forEach(location => {
                const marker = L.marker(location.coords, {
                    icon: waterMonitoringIcon
                })
                .bindPopup(`
                    <strong>${location.name}</strong><br>
                    <em>Water Monitoring Location</em><br>
                    <button onclick="showWaterMonitoringGraph('${location.name.toLowerCase().replace(' ', '-')}')">View Trends</button>
                `)
                .addTo(map);

                waterMonitoringMarkers.push(marker);
            });
        }

        // Hide water monitoring markers
        function hideWaterMonitoringMarkers() {
            waterMonitoringMarkers.forEach(marker => {
                if (map.hasLayer(marker)) {
                    map.removeLayer(marker);
                }
            });
            waterMonitoringMarkers = [];
        }

        // Show water monitoring graph for a location
        window.showWaterMonitoringGraph = function(locationKey) {
            const location = waterMonitoringLocations[locationKey];
            if (!location) return;

            // Load water monitoring data for this location
            loadWaterMonitoringData(locationKey).then(data => {
                if (data && data.length > 0) {
                    showWaterMonitoringChart(location.name, data);
                } else {
                    alert(`No water monitoring data available for ${location.name}`);
                }
            });
        };

        // Load water monitoring data for a location
        async function loadWaterMonitoringData(locationKey) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/water-monitoring?location=${locationKey}`, {
                    headers: getAuthHeaders()
                });
                if (!response.ok) throw new Error(`Failed to load water monitoring data`);

                const data = await response.json();
                return data.success ? data.data : [];
            } catch (error) {
                console.error('Error loading water monitoring data:', error);
                return [];
            }
        }

        // Show water monitoring chart
        function showWaterMonitoringChart(locationName, data) {
            // Create modal or overlay for chart
            const chartModal = document.createElement('div');
            chartModal.className = 'chart-modal';
            chartModal.innerHTML = `
                <div class="chart-modal-content">
                    <div class="chart-modal-header">
                        <h3>Water Quality Trends - ${locationName}</h3>
                        <button class="chart-close-btn">&times;</button>
                    </div>
                    <div class="chart-container">
                        <canvas id="waterChart"></canvas>
                    </div>
                </div>
            `;

            document.body.appendChild(chartModal);

            // Close modal functionality
            chartModal.querySelector('.chart-close-btn').onclick = () => {
                document.body.removeChild(chartModal);
            };

            chartModal.onclick = (e) => {
                if (e.target === chartModal) {
                    document.body.removeChild(chartModal);
                }
            };

            // Prepare data for Chart.js
            const sortedData = data.sort((a, b) => new Date(a.date) - new Date(b.date));

            const chartData = {
                labels: sortedData.map(d => new Date(d.date).toLocaleDateString()),
                datasets: [
                    {
                        label: 'Conductivity (micro/cm)',
                        data: sortedData.map(d => d.cond),
                        borderColor: '#ff6384',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        yAxisID: 'y'
                    },
                    {
                        label: 'TDS (ppm)',
                        data: sortedData.map(d => d.tds),
                        borderColor: '#36a2eb',
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        yAxisID: 'y'
                    },
                    {
                        label: 'Arsenic (ppm)',
                        data: sortedData.map(d => d.as),
                        borderColor: '#cc65fe',
                        backgroundColor: 'rgba(204, 101, 254, 0.1)',
                        yAxisID: 'y1'
                    },
                    {
                        label: 'Chromium (ppm)',
                        data: sortedData.map(d => d.cr),
                        borderColor: '#ff9f40',
                        backgroundColor: 'rgba(255, 159, 64, 0.1)',
                        yAxisID: 'y1'
                    },
                    {
                        label: 'Copper (ppm)',
                        data: sortedData.map(d => d.cu),
                        borderColor: '#ffcd56',
                        backgroundColor: 'rgba(255, 205, 86, 0.1)',
                        yAxisID: 'y1'
                    },
                    {
                        label: 'Manganese (ppm)',
                        data: sortedData.map(d => d.mn),
                        borderColor: '#4bc0c0',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        yAxisID: 'y1'
                    },
                    {
                        label: 'Sodium (ppm)',
                        data: sortedData.map(d => d.na),
                        borderColor: '#c9cbcf',
                        backgroundColor: 'rgba(201, 203, 207, 0.1)',
                        yAxisID: 'y'
                    },
                    {
                        label: 'Lead (ppm)',
                        data: sortedData.map(d => d.pb),
                        borderColor: '#ff6384',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        yAxisID: 'y1'
                    }
                ]
            };

            const config = {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Conductivity, TDS, Sodium (ppm)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Heavy Metals (ppm)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom'
                        }
                    }
                }
            };

            new Chart(document.getElementById('waterChart'), config);
        }

        // Clear sightings markers (for water monitoring mode)
        function clearSightingsMarkers() {
            // Clear all observation markers when in water monitoring mode
            observationsLayer.clearLayers();
            clearLatestMarkers();
            hideSpeciesLegend();
        }

        function applyFilters() {
            // Clear all markers first
            observationsLayer.clearLayers();
            clearLatestMarkers();

            // Apply date filters
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const selectedMonth = document.getElementById('month-select').value;
            const selectedYear = document.getElementById('year-select').value;

            // Filter observations based on current view and filters
            const filteredObservations = allObservations.filter(obs => {
                // View filter
                if (currentView === 'sightings' && obs.category !== 'Sighting') return false;
                if (currentView === 'maintenance' && obs.category !== 'Maintenance') return false;
                if (currentView === 'incidents' && obs.category !== 'Incident') return false;

                // Date range filter
                if (startDate || endDate) {
                    const obsDate = new Date(obs.timestamp);
                    if (startDate && obsDate < new Date(startDate)) return false;
                    if (endDate && obsDate > new Date(endDate + 'T23:59:59')) return false;
                }

                // Month/Year filter
                if (selectedMonth || selectedYear) {
                    const obsDate = new Date(obs.timestamp);
                    if (selectedMonth && obsDate.getMonth() + 1 !== parseInt(selectedMonth)) return false;
                    if (selectedYear && obsDate.getFullYear() !== parseInt(selectedYear)) return false;
                }

                // Species filter (sightings only)
                if (currentView === 'sightings') {
                    const selectedSpecies = document.getElementById('species-select').value;
                    if (selectedSpecies && obs.animal !== selectedSpecies) return false;
                }

                return true;
            });

            if (displayMode === 'hotspot') {
                // Create heat map using Leaflet.heat plugin
                // Use ALL observations within date range for hotspots, not filtered by current view
                const hotspotObservations = allObservations.filter(obs => {
                    // Date range filter
                    if (startDate || endDate) {
                        const obsDate = new Date(obs.timestamp);
                        if (startDate && obsDate < new Date(startDate)) return false;
                        if (endDate && obsDate > new Date(endDate + 'T23:59:59')) return false;
                    }

                    // Month/Year filter
                    if (selectedMonth || selectedYear) {
                        const obsDate = new Date(obs.timestamp);
                        if (selectedMonth && obsDate.getMonth() + 1 !== parseInt(selectedMonth)) return false;
                        if (selectedYear && obsDate.getFullYear() !== parseInt(selectedYear)) return false;
                    }

                    return obs.latitude && obs.longitude;
                });

                const points = hotspotObservations
                    .map(obs => [obs.latitude, obs.longitude, 1]); // [lat, lng, intensity]

                console.log('Hotspot mode: showing', points.length, 'points from date-filtered observations');

                if (points.length > 0) {
                    const heatLayer = L.heatLayer(points, {
                        radius: 25,      // smaller, denser hotspots
                        blur: 15,        // less blur for sharper hotspots
                        maxZoom: 17,
                        minOpacity: 0.6, // less transparent
                        // blue → green → yellow → red
                        gradient: {
                            0.0: '#2c7bb6',
                            0.25: '#00a6ca',
                            0.45: '#00ccbc',
                            0.6: '#90eb9d',
                            0.75: '#ffff8c',
                            0.9: '#f9d057',
                            1.0: '#d7191c'
                        }
                    }).addTo(observationsLayer);
                }
            } else {
                // Show individual markers (actual locations)
                filteredObservations.forEach(observation => {
                    if (observation.latitude && observation.longitude) {
                        let icon, popupContent;

                        switch (observation.category) {
                            case 'Sighting':
                                icon = sightingIcon;
                                popupContent = `
                                    <strong>Animal Sighting</strong><br>
                                    <strong>Species:</strong> ${observation.animal || 'Unknown'}<br>
                                    <strong>Time:</strong> ${new Date(observation.timestamp).toLocaleString()}<br>
                                    <strong>Location:</strong> ${observation.latitude.toFixed(4)}, ${observation.longitude.toFixed(4)}
                                `;
                                break;
                            case 'Incident':
                                icon = incidentIcon;
                                popupContent = `
                                    <strong>Incident Report</strong><br>
                                    <strong>Type:</strong> ${observation.incident_type || 'Unknown'}<br>
                                    <strong>Time:</strong> ${new Date(observation.timestamp).toLocaleString()}<br>
                                    <strong>Location:</strong> ${observation.latitude.toFixed(4)}, ${observation.longitude.toFixed(4)}
                                `;
                                break;
                            case 'Maintenance':
                                icon = maintenanceIcon;
                                popupContent = `
                                    <strong>Maintenance Activity</strong><br>
                                    <strong>Type:</strong> ${observation.maintenance_type || 'Unknown'}<br>
                                    <strong>Time:</strong> ${new Date(observation.timestamp).toLocaleString()}<br>
                                    <strong>Location:</strong> ${observation.latitude.toFixed(4)}, ${observation.longitude.toFixed(4)}
                                `;
                                break;
                        }

                            // For actual locations, use species-specific colors for sightings
                            if (displayMode === 'actual' && observation.category === 'Sighting') {
                                const animalName = (observation.animal || '').toLowerCase().replace(/\s+/g, '-');
                                const speciesColor = speciesColors[animalName] || '#8B4513';
                                icon = createCustomIcon(speciesColor);
                            }

                            const marker = L.marker([observation.latitude, observation.longitude], { icon })
                                .bindPopup(popupContent);

                            marker.addTo(observationsLayer);
                    }
                });
            }

            // Apply latest toggles
            applyLatestFilters();

            updateStats();
        }

        function applyLatestFilters() {
            console.log('Applying latest filters');
            clearLatestMarkers();

            // Show black pins for recent observations by category
            if (document.getElementById('latest-sightings-toggle').checked) {
                console.log('Showing black pins for recent sightings');
                showLatestSightings();
            }

            if (document.getElementById('latest-maintenance-toggle').checked) {
                console.log('Showing black pins for recent maintenance');
                showLatestMaintenance();
            }

            if (document.getElementById('latest-incidents-toggle').checked) {
                console.log('Showing black pins for recent incidents');
                showLatestIncidents();
            }

            console.log('Latest markers created:', latestMarkers.length);
        }

        function showLatestSightings() {
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

            console.log('Showing black pins for recent SIGHTINGS from past week');

            let markerCount = 0;

            // Show simple black pins for recent SIGHTINGS only
            allObservations.forEach(obs => {
                const obsDate = new Date(obs.timestamp);
                const isRecent = obsDate > oneWeekAgo;

                if (isRecent && obs.latitude && obs.longitude && obs.category === 'Sighting') {
                    // Simple black pin for sightings
                    const blackPinIcon = L.divIcon({
                        className: 'black-pin-sighting',
                        html: `<div style="
                            background-color: #000000;
                            width: 8px;
                            height: 8px;
                            border-radius: 50%;
                            border: 1px solid #ffffff;
                        "></div>`,
                        iconSize: [8, 8],
                        iconAnchor: [4, 4]
                    });

                    const marker = L.marker([obs.latitude, obs.longitude], { icon: blackPinIcon })
                        .bindPopup(`
                            <strong>🐘 RECENT SIGHTING (This Week)</strong><br>
                            <strong>Species:</strong> ${obs.animal || 'Unknown'}<br>
                            <strong>Time:</strong> ${obsDate.toLocaleString()}<br>
                            <strong>Location:</strong> ${obs.latitude.toFixed(4)}, ${obs.longitude.toFixed(4)}
                        `);

                    marker.addTo(observationsLayer);
                    latestMarkers.push(marker);
                    markerCount++;
                }
            });

            console.log('Total black pins created for recent sightings:', markerCount);
        }

        function showLatestMaintenance() {
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

            console.log('Showing black pins for recent MAINTENANCE from past week');

            let markerCount = 0;

            // Show simple black pins for recent MAINTENANCE only
            allObservations.forEach(obs => {
                const obsDate = new Date(obs.timestamp);
                const isRecent = obsDate > oneWeekAgo;

                if (isRecent && obs.latitude && obs.longitude && obs.category === 'Maintenance') {
                    // Simple black pin for maintenance
                    const blackPinIcon = L.divIcon({
                        className: 'black-pin-maintenance',
                        html: `<div style="
                            background-color: #000000;
                            width: 8px;
                            height: 8px;
                            border-radius: 50%;
                            border: 1px solid #ffffff;
                        "></div>`,
                        iconSize: [8, 8],
                        iconAnchor: [4, 4]
                    });

                    const marker = L.marker([obs.latitude, obs.longitude], { icon: blackPinIcon })
                        .bindPopup(`
                            <strong>🔧 RECENT MAINTENANCE (This Week)</strong><br>
                            <strong>Type:</strong> ${obs.maintenance_type || 'Unknown'}<br>
                            <strong>Time:</strong> ${obsDate.toLocaleString()}<br>
                            <strong>Location:</strong> ${obs.latitude.toFixed(4)}, ${obs.longitude.toFixed(4)}
                        `);

                    marker.addTo(observationsLayer);
                    latestMarkers.push(marker);
                    markerCount++;
                }
            });

            console.log('Total black pins created for recent maintenance:', markerCount);
        }

        function showLatestIncidents() {
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

            console.log('Showing black pins for recent INCIDENTS from past week');

            let markerCount = 0;

            // Show simple black pins for recent INCIDENTS only
            allObservations.forEach(obs => {
                const obsDate = new Date(obs.timestamp);
                const isRecent = obsDate > oneWeekAgo;

                if (isRecent && obs.latitude && obs.longitude && obs.category === 'Incident') {
                    // Simple black pin for incidents
                    const blackPinIcon = L.divIcon({
                        className: 'black-pin-incident',
                        html: `<div style="
                            background-color: #000000;
                            width: 8px;
                            height: 8px;
                            border-radius: 50%;
                            border: 1px solid #ffffff;
                        "></div>`,
                        iconSize: [8, 8],
                        iconAnchor: [4, 4]
                    });

                    const marker = L.marker([obs.latitude, obs.longitude], { icon: blackPinIcon })
                        .bindPopup(`
                            <strong>🚨 RECENT INCIDENT (This Week)</strong><br>
                            <strong>Type:</strong> ${obs.incident_type || 'Unknown'}<br>
                            <strong>Time:</strong> ${obsDate.toLocaleString()}<br>
                            <strong>Location:</strong> ${obs.latitude.toFixed(4)}, ${obs.longitude.toFixed(4)}
                        `);

                    marker.addTo(observationsLayer);
                    latestMarkers.push(marker);
                    markerCount++;
                }
            });

            console.log('Total black pins created for recent incidents:', markerCount);
        }

        function updateStats() {
            const filteredCount = observationsLayer.getLayers().length - latestMarkers.length;

            if (currentView === 'sightings') {
                document.getElementById('total-records').textContent = filteredCount;
            } else if (currentView === 'maintenance') {
                document.getElementById('maintenance-records').textContent = filteredCount;
            } else if (currentView === 'incidents') {
                document.getElementById('incident-records').textContent = filteredCount;
            }
        }

        // Submit water monitoring data
        async function submitWaterMonitoringData() {
            const locationSelect = document.getElementById('water-location-select');
            const locationKey = locationSelect.value;

            if (!locationKey) {
                alert('Please select a location');
                return;
            }

            const location = waterMonitoringLocations[locationKey];
            if (!location) {
                alert('Invalid location selected');
                return;
            }

            // Collect form data
            const waterData = {
                location: locationKey,
                location_name: location.name,
                latitude: location.coords[0],
                longitude: location.coords[1],
                date: document.getElementById('water-date-input').value,
                cond: parseFloat(document.getElementById('cond-input').value) || null,
                tds: parseFloat(document.getElementById('tds-input').value) || null,
                as: parseFloat(document.getElementById('as-input').value) || null,
                cr: parseFloat(document.getElementById('cr-input').value) || null,
                cu: parseFloat(document.getElementById('cu-input').value) || null,
                mn: parseFloat(document.getElementById('mn-input').value) || null,
                na: parseFloat(document.getElementById('na-input').value) || null,
                pb: parseFloat(document.getElementById('pb-input').value) || null
            };

            // Validate required fields
            if (!waterData.date) {
                alert('Please select a date');
                return;
            }

            // Check if at least one parameter is provided
            const hasData = [waterData.cond, waterData.tds, waterData.as, waterData.cr,
                           waterData.cu, waterData.mn, waterData.na, waterData.pb].some(val => val !== null);
            if (!hasData) {
                alert('Please enter at least one water quality parameter');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/water-monitoring`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify(waterData)
                });

                if (!response.ok) throw new Error(`Failed to submit water monitoring data`);

                const result = await response.json();
                if (result.success) {
                    alert('Water monitoring data submitted successfully!');

                    // Clear form
                    document.getElementById('water-date-input').value = '';
                    ['cond-input', 'tds-input', 'as-input', 'cr-input', 'cu-input', 'mn-input', 'na-input', 'pb-input'].forEach(id => {
                        document.getElementById(id).value = '';
                    });
                } else {
                    throw new Error(result.message || 'Failed to submit data');
                }
            } catch (error) {
                console.error('Error submitting water monitoring data:', error);
                alert('Failed to submit water monitoring data: ' + error.message);
            }
        }

        // Set up all event listeners
        function setupFilters() {
            // View mode dropdown
            document.getElementById('view-mode-select').addEventListener('change', function() {
                currentView = this.value;

                    // Show/hide appropriate controls
                    document.getElementById('species-group').style.display =
                        currentView === 'sightings' ? 'block' : 'none';
                    document.getElementById('maintenance-group').style.display =
                        currentView === 'maintenance' ? 'block' : 'none';
                    document.getElementById('incidents-group').style.display =
                        currentView === 'incidents' ? 'block' : 'none';
                    // Water monitoring group stays visible to allow switching back
                    document.getElementById('water-monitoring-group').style.display = 'block';

                    // Show/hide date controls for water monitoring
                    const allControlGroups = document.querySelectorAll('.control-group');

                    if (currentView === 'water-monitoring') {
                        // Hide date range and month/year controls (first two groups)
                        allControlGroups[0].style.display = 'none'; // Date Range
                        allControlGroups[1].style.display = 'none'; // Month & Year
                    } else {
                        // Show date controls for other views
                        allControlGroups[0].style.display = 'block'; // Date Range
                        allControlGroups[1].style.display = 'block'; // Month & Year
                    }

                    // Show/hide species legend for actual locations mode
                    if (displayMode === 'actual' && currentView === 'sightings') {
                        showSpeciesLegend();
                    } else {
                        hideSpeciesLegend();
                    }

                    // Water monitoring markers are always shown
                    showWaterMonitoringMarkers();

                    // For water monitoring mode, don't clear sightings - let them show alongside water markers
                    if (currentView !== 'water-monitoring') {
                        clearSightingsMarkers();
                    } else {
                        // In water monitoring mode, make sure sightings are visible
                        applyFilters();
                    }

                    // Reapply filters
                    applyFilters();
            });

            // Display mode switch (Hotspots/Actual)
            document.getElementById('display-mode-toggle').addEventListener('change', function() {
                displayMode = this.checked ? 'hotspot' : 'actual';

                // Update switch text
                const switchText = this.parentElement.querySelector('.switch-text');
                switchText.textContent = this.checked ? 'Hotspots' : 'Actual';

                // Show/hide species legend for actual locations mode
                if (displayMode === 'actual' && currentView === 'sightings') {
                    showSpeciesLegend();
                } else {
                    hideSpeciesLegend();
                }

                applyFilters();
            });

            // Date filters
            ['start-date', 'end-date', 'month-select', 'year-select'].forEach(id => {
                document.getElementById(id).addEventListener('change', applyFilters);
            });

            // Species filter
            document.getElementById('species-select').addEventListener('change', applyFilters);

            // Latest toggles for each category
            ['latest-sightings-toggle', 'latest-maintenance-toggle', 'latest-incidents-toggle'].forEach(id => {
                document.getElementById(id).addEventListener('change', applyLatestFilters);
            });

            // Water monitoring location selector
            document.getElementById('water-location-select').addEventListener('change', function() {
                const waterParams = document.getElementById('water-params');
                waterParams.style.display = this.value ? 'block' : 'none';
            });

            // Water monitoring submit button
            document.getElementById('submit-water-data').addEventListener('click', submitWaterMonitoringData);
        }

        // Start the map
        initMap();
        setupFilters();

    </script>
</body>
</html>
